---
title: "LSW Power Simulation"
output: html_document
---

* list
    + list2


```{r start, warning=FALSE, message=FALSE}
# load necessary libraries
  library(zoo)
	library(xts)
	library(knitr)
	library(xtable)
	library(stargazer)
	library(psych)
	library(ggplot2)
# set variables
    # time series
	ts <- 50
	# cross section of firms
	cs <-25
	# number of erps
	erhat <- 4
	# gen id
	id <- seq(1, ts, by=1)
	# gen blank vectors for storing results
    #for storing k variables
	    power_mvar_k <- vector()     
	    power_svar_k <- vector()
    #for storing stored results
  	  power_svar <- vector()
  	  power_mvar <- vector()
	# gen vector to increase k
  kmax <- c(seq(.01,1,.01),seq(1,4,.1))
```

******
# First Simulation
* Purpose: compare m/svar calculated for every time series and cross section
* Number of Repetitions: `r length(kmax)`; k increases by .01 from .01 to 1

**Steps**

1. Generate `exr`, `news`, `rr`, `erp1-4`; these are generated anew for every loop in the simulation. The number of loops in the simulation are determined by the length of the vector `kmax`. This vector is an increasing sequence from .01 to 1 by .01 (100x). Everytime the sequence increases, and the loop starts over, the amount of variability news in increases. This is because kmax is the upper limit on the uniform distribution where news is being drawn from. When the loop begins at .01, the amount of noise injected into `rr` is at its lowest. It will then increase everytime the loop starts over until it reaches one. We can measure noise by taking the ratio of the average variance of expected returns / average variance of realized returns. The step is the same in all simulations

2. Calculate m/svar --- instead of taking average m/svar, we compare direclty each vector of m/svar generated. For example, when calculating mvar (ts) we end up with, for each erp, a vector of length `r ts` where each element of this mvar vector is the mvar for each time series. In the paper, the average of this vector is calculated and compared between erps. In this simulation we will compare each element of the vector directly and not use the average.  For example, the time series of firm one will have an mvar for erp1 and an mvar for erp2. If the mvar for erp1 is less than the mvar for erp2 in this case, then it is recorded as a correct rank ordering. This is repeated for svar.

3. We then plot what we find.

```{r sim1}
#for loop
 for(k in 1:length(kmax)){

	# ######################################################################

	# generate expected returns
		exr <- data.frame(replicate(cs,runif(ts, min=.01, max=.2)))
		# rename columns
		colnames(exr) <- c(paste("exr",seq(from=1, to=cs, by=1),sep=""))

	# ######################################################################
	 
	# generate news
		# generate shock
		shock <- runif(ts,min=0,max=1)
		shock <- ifelse(shock>.5,1,-1)
		# generate news
		random_noise <- replicate(cs,runif(ts,min=.01,max=kmax[k]))
		news <-data.frame(shock*random_noise*exr)
		# rename columns
		colnames(news) <- c(paste("news",seq(from=1, to=cs, by=1),sep=""))

	# ######################################################################

	# generate realized returns
		rr <- data.frame(exr+news)
		colnames(rr) <- c(paste("rr",seq(from=1, to=cs, by=1),sep=""))

	# ######################################################################

	# generate erps
		# erp1
		erp1 <- data.frame(exr + replicate(cs, runif(ts,min=.01,max=.2)))
		colnames(erp1) <- c(paste("erp1_",seq(from=1, to=cs, by=1),sep=""))
		# erp2
		erp2 <- data.frame(exr+replicate(cs, runif(ts,min=.01,max=.4)))
		colnames(erp2) <- c(paste("erp2_",seq(from=1, to=cs, by=1),sep=""))	
		# erp3
		erp3 <- data.frame(exr+replicate(cs, runif(ts,min=.01,max=.8)))
		colnames(erp3) <- c(paste("erp3_",seq(from=1, to=cs, by=1),sep=""))	
		# erp4
		erp4 <- data.frame(exr+replicate(cs, runif(ts,min=.01,max=1)))
		colnames(erp4) <- c(paste("erp4_",seq(from=1, to=cs, by=1),sep=""))
	# ######################################################################

	# ######################################################################
	  #calculate mvar k
	  mvar_k <- var(stack(exr)[,1]) / var(stack(rr)[,1])
	  # add mvar_k to k vector
	  power_mvar_k <- append(power_mvar_k,mvar_k)
	  #calculate svar k
	  svar_k <- mean(apply(exr,1,var)) / mean(apply(rr,1,var))
	  # add svar_k to k vector
	  power_svar_k <- append(power_svar_k,svar_k)
	  
	# ######################################################################

	# initiate blank vector
	mvar_avg <- vector()
	# initiate blank vector to contain all mvars for each erp
	mvar_all <- data.frame(ts=id)
	# use a bad for loop, need to move away from this
	for(i in 1:erhat){
	  # set erp to be erp1...4 depending on position in loop
	  erp <- paste("erp",i,sep="")
	  # save covariance matrix of rr and erp1...4
	  mvar_cov <- cov(rr, get(erp))
	  # extract the diagonal for the covariance
	  mvar_cov <- diag(mvar_cov)
	  # get variance of erp1...4
	  mvar_var <- var(get(erp))
	  # extract the diagonal
	  mvar_var <- diag(mvar_var)
	  # calculate lsw
	  mvar <- mvar_var-2*mvar_cov
	  # remove names
	  mvar <- unname(mvar)
	  # add calculated mvar vector to initalized vector 
	  mvar_all<-cbind(mvar_all,mvar)
	  # add to original vector
	  mvar_avg <- append(mvar_avg,mean(mvar))
	}

	# initiate blank vector
	svar_avg <- vector()
	# initiate blank vector to contain all mvars for each erp
	svar_all <- data.frame(cs=id)
	# rotate/transpose realized return vector so that cross sections are now columns
	rrt <- t(rr)
	# use a bad for loop, need to move away from this
	for(i in 1:erhat){
		# set erp to be erp1...4 depending on position in loop
		erp <- paste("erp",i,sep="")
		# transpose/rotate erp1...4
		erpt <- t(get(erp))
		# save covariance matrix of rr and erp1...4
		svar_cov <- cov(rrt, erpt)
		# extract the diagonal for the covariance
		svar_cov <- diag(svar_cov)
		# get variance of erp1...4
		svar_var <- var(erpt)
		# extract the diagonal
		svar_var <- diag(svar_var)
		# calculate lsw
		svar <- svar_var-2*svar_cov
		# remove names
		svar <- unname(svar)
		# add calculated mvar vector to initalized vector 
		svar_all<-cbind(svar_all,svar)
		# add to original vector
		svar_avg <- append(svar_avg,mean(svar))
	}

	# percentage of time mvar1 is less than mvar2
	mvar_rank <- mvar_all[,2] < mvar_all[,3]
	mvar_rank_order <- length(mvar_rank[mvar_rank==TRUE])/length(mvar_rank)
	power_mvar <- append(power_mvar,mvar_rank_order)

	# percentage of time mvar1 is less than mvar2
	svar_rank <- svar_all[,2] < svar_all[,3]
	svar_rank_order <- length(svar_rank[svar_rank==TRUE])/length(svar_rank)
	power_svar <- append(power_svar,svar_rank_order)

}
```

```{r look, echo=FALSE}
my<-rev(power_mvar_k)
mx<-rev(power_mvar)
sy<-rev(power_svar_k)
sx<-rev(power_svar)

qplot(my, geom="histogram", ylab="Count", xlab="K: Time Series")
qplot(sy, geom="histogram", ylab="Count", xlab="K: Cross Section")

qplot(power_mvar_k,power_mvar)
qplot(power_svar_k,power_svar)




```

another chart = is erp1 less than erp2 


